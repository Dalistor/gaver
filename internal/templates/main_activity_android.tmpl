package {{.PackageName}};

import android.os.Bundle;
import android.util.Log;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.IOException;

import com.getcapacitor.BridgeActivity;

public class MainActivity extends BridgeActivity {
    private static final String TAG = "MainActivity";
    private Process serverProcess;

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        
        // Iniciar servidor Go em thread separada
        new Thread(() -> {
            try {
                startGoServer();
            } catch (Exception e) {
                Log.e(TAG, "Erro ao iniciar servidor Go", e);
            }
        }).start();
    }

    private void startGoServer() {
        try {
            // Caminho do binário do servidor Go no assets
            String serverBinary = "server";
            
            // Obter diretório de dados do app (onde o SQLite será armazenado)
            File dataDir = getApplicationContext().getFilesDir();
            String appDataDir = dataDir.getAbsolutePath();
            
            // Criar subdiretório 'data' para o banco SQLite
            File dbDir = new File(dataDir, "data");
            if (!dbDir.exists()) {
                dbDir.mkdirs();
            }
            
            // Verificar se existe banco embutido nos assets e copiar para diretório de dados
            File embeddedDB = new File(dbDir, "database.db");
            File finalDB = new File(dbDir, "{{.ProjectName}}.db");
            if (!finalDB.exists() && assetExists("database.db")) {
                try {
                    copyAssetToFile("database.db", embeddedDB);
                    // Renomear para o nome correto do banco
                    embeddedDB.renameTo(finalDB);
                    Log.i(TAG, "Banco SQLite embutido copiado dos assets");
                } catch (IOException e) {
                    Log.e(TAG, "Erro ao copiar banco SQLite embutido", e);
                }
            }
            
            // Copiar binário do assets para o diretório de dados do app
            File serverFile = new File(dataDir, serverBinary);
            
            if (!serverFile.exists()) {
                // Copiar do assets
                copyAssetToFile(serverBinary, serverFile);
                // Tornar executável
                serverFile.setExecutable(true);
            }

            // Iniciar o servidor com APP_DATA_DIR configurado
            ProcessBuilder pb = new ProcessBuilder(serverFile.getAbsolutePath());
            pb.directory(dataDir);
            pb.redirectErrorStream(true);
            
            // Configurar APP_DATA_DIR para o SQLite usar o diretório correto
            pb.environment().put("APP_DATA_DIR", dbDir.getAbsolutePath());
            
            serverProcess = pb.start();
            
            Log.i(TAG, "Servidor Go iniciado com sucesso");
            Log.i(TAG, "APP_DATA_DIR configurado: " + dbDir.getAbsolutePath());
            
        } catch (Exception e) {
            Log.e(TAG, "Erro ao iniciar servidor Go: " + e.getMessage(), e);
        }
    }

    private void copyAssetToFile(String assetName, File destFile) throws IOException {
        InputStream is = getAssets().open(assetName);
        FileOutputStream fos = new FileOutputStream(destFile);
        
        byte[] buffer = new byte[8192];
        int bytesRead;
        while ((bytesRead = is.read(buffer)) != -1) {
            fos.write(buffer, 0, bytesRead);
        }
        
        fos.close();
        is.close();
    }
    
    private boolean assetExists(String assetName) {
        try {
            InputStream is = getAssets().open(assetName);
            is.close();
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        
        // Parar servidor Go quando o app fechar
        if (serverProcess != null) {
            serverProcess.destroy();
            try {
                serverProcess.waitFor();
            } catch (InterruptedException e) {
                Log.e(TAG, "Erro ao aguardar término do servidor", e);
            }
        }
    }
}

