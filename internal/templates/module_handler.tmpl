package handlers

import (
	"{{.ProjectName}}/modules/{{.ModuleName}}/models"
	"{{.ProjectName}}/modules/{{.ModuleName}}/services"
	"github.com/gin-gonic/gin"
	"strconv"
)

type {{.ModelName}}Handler struct {
	service *services.{{.ModelName}}Service
}

func New{{.ModelName}}Handler(service *services.{{.ModelName}}Service) *{{.ModelName}}Handler {
	return &{{.ModelName}}Handler{service: service}
}

{{if .HasList}}
// List retorna todos os {{.ModelNameLower}}s
func (h *{{.ModelName}}Handler) List(c *gin.Context) {
	// Callback antes de listar
	if err := h.BeforeList(c); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	items, err := h.service.List()
	if err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	// Callback após listar
	items = h.AfterList(c, items)

	// Filtrar campos readable
	items = h.FilterReadableFields(items)

	c.JSON(200, items)
}
{{end}}

{{if .HasGet}}
// Get retorna um {{.ModelNameLower}} específico
func (h *{{.ModelName}}Handler) Get(c *gin.Context) {
	id := c.Param("id")

	// Callback antes de buscar
	if err := h.BeforeGet(c, id); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	item, err := h.service.Get(id)
	if err != nil {
		c.JSON(404, gin.H{"error": "Não encontrado"})
		return
	}

	// Callback após buscar
	item = h.AfterGet(c, item)

	// Filtrar campos readable
	item = h.FilterReadableField(item)

	c.JSON(200, item)
}
{{end}}

{{if .HasCreate}}
// Create cria um novo {{.ModelNameLower}}
func (h *{{.ModelName}}Handler) Create(c *gin.Context) {
	var data map[string]interface{}
	if err := c.ShouldBindJSON(&data); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	// Filtrar campos writable para POST
	data = h.FilterWritableFields(data, "POST")

	// Validação personalizada
	if err := h.OnValidate(data, "CREATE"); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	// Callback antes de criar
	if err := h.BeforeCreate(c, data); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	item, err := h.service.Create(data)
	if err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	// Callback após criar
	item = h.AfterCreate(c, item)

	// Filtrar campos readable
	item = h.FilterReadableField(item)

	c.JSON(201, item)
}
{{end}}

{{if .HasUpdate}}
// Update atualiza um {{.ModelNameLower}}
func (h *{{.ModelName}}Handler) Update(c *gin.Context) {
	id := c.Param("id")

	var data map[string]interface{}
	if err := c.ShouldBindJSON(&data); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	// Filtrar campos writable para PUT
	data = h.FilterWritableFields(data, "PUT")

	// Validação personalizada
	if err := h.OnValidate(data, "UPDATE"); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	// Callback antes de atualizar
	if err := h.BeforeUpdate(c, id, data); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	item, err := h.service.Update(id, data)
	if err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	// Callback após atualizar
	item = h.AfterUpdate(c, item)

	// Filtrar campos readable
	item = h.FilterReadableField(item)

	c.JSON(200, item)
}
{{end}}

{{if .HasPatch}}
// Patch atualiza parcialmente um {{.ModelNameLower}}
func (h *{{.ModelName}}Handler) Patch(c *gin.Context) {
	id := c.Param("id")

	var data map[string]interface{}
	if err := c.ShouldBindJSON(&data); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	// Filtrar campos writable para PATCH
	data = h.FilterWritableFields(data, "PATCH")

	// Validação personalizada
	if err := h.OnValidate(data, "PATCH"); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	// Callback antes de atualizar
	if err := h.BeforePatch(c, id, data); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	item, err := h.service.Update(id, data)
	if err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	// Callback após atualizar
	item = h.AfterPatch(c, item)

	// Filtrar campos readable
	item = h.FilterReadableField(item)

	c.JSON(200, item)
}
{{end}}

{{if .HasDelete}}
// Delete remove um {{.ModelNameLower}}
func (h *{{.ModelName}}Handler) Delete(c *gin.Context) {
	id := c.Param("id")

	// Callback antes de deletar
	if err := h.BeforeDelete(c, id); err != nil {
		c.JSON(400, gin.H{"error": err.Error()})
		return
	}

	if err := h.service.Delete(id); err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	// Callback após deletar
	h.AfterDelete(c, id)

	c.JSON(204, nil)
}
{{end}}

// ============= CALLBACKS (podem ser sobrescritos) =============

{{if .HasList}}
func (h *{{.ModelName}}Handler) BeforeList(c *gin.Context) error {
	// Override este método para adicionar lógica antes de listar
	return nil
}

func (h *{{.ModelName}}Handler) AfterList(c *gin.Context, items []models.{{.ModelName}}) []models.{{.ModelName}} {
	// Override este método para modificar resultado
	return items
}
{{end}}

{{if .HasGet}}
func (h *{{.ModelName}}Handler) BeforeGet(c *gin.Context, id string) error {
	// Override este método para adicionar lógica antes de buscar
	return nil
}

func (h *{{.ModelName}}Handler) AfterGet(c *gin.Context, item models.{{.ModelName}}) models.{{.ModelName}} {
	// Override este método para modificar resultado
	return item
}
{{end}}

{{if .HasCreate}}
func (h *{{.ModelName}}Handler) BeforeCreate(c *gin.Context, data map[string]interface{}) error {
	// Override este método para adicionar lógica antes de criar
	// Exemplo: Hash de senha, validações customizadas, etc
	return nil
}

func (h *{{.ModelName}}Handler) AfterCreate(c *gin.Context, item models.{{.ModelName}}) models.{{.ModelName}} {
	// Override este método para modificar resultado
	return item
}
{{end}}

{{if .HasUpdate}}
func (h *{{.ModelName}}Handler) BeforeUpdate(c *gin.Context, id string, data map[string]interface{}) error {
	// Override este método para adicionar lógica antes de atualizar
	return nil
}

func (h *{{.ModelName}}Handler) AfterUpdate(c *gin.Context, item models.{{.ModelName}}) models.{{.ModelName}} {
	// Override este método para modificar resultado
	return item
}
{{end}}

{{if .HasPatch}}
func (h *{{.ModelName}}Handler) BeforePatch(c *gin.Context, id string, data map[string]interface{}) error {
	// Override este método para adicionar lógica antes de atualizar parcialmente
	return nil
}

func (h *{{.ModelName}}Handler) AfterPatch(c *gin.Context, item models.{{.ModelName}}) models.{{.ModelName}} {
	// Override este método para modificar resultado
	return item
}
{{end}}

{{if .HasDelete}}
func (h *{{.ModelName}}Handler) BeforeDelete(c *gin.Context, id string) error {
	// Override este método para adicionar lógica antes de deletar
	return nil
}

func (h *{{.ModelName}}Handler) AfterDelete(c *gin.Context, id string) {
	// Override este método para adicionar lógica após deletar
}
{{end}}

// OnValidate executa validações customizadas
func (h *{{.ModelName}}Handler) OnValidate(data map[string]interface{}, operation string) error {
	// Override este método para adicionar validações customizadas
	// operation pode ser: CREATE, UPDATE, PATCH
	return nil
}

// FilterWritableFields filtra campos que podem ser escritos no método especificado
func (h *{{.ModelName}}Handler) FilterWritableFields(data map[string]interface{}, method string) map[string]interface{} {
	// TODO: Implementar baseado nas annotations do model
	// Por enquanto, retorna todos os campos
	return data
}

// FilterReadableFields filtra campos que podem ser lidos
func (h *{{.ModelName}}Handler) FilterReadableFields(items []models.{{.ModelName}}) []models.{{.ModelName}} {
	// TODO: Implementar baseado nas annotations do model
	// Por enquanto, retorna todos os campos
	return items
}

// FilterReadableField filtra campos que podem ser lidos (item único)
func (h *{{.ModelName}}Handler) FilterReadableField(item models.{{.ModelName}}) models.{{.ModelName}} {
	// TODO: Implementar baseado nas annotations do model
	// Por enquanto, retorna todos os campos
	return item
}

